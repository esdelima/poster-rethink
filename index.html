<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Poster AR — Anchor 4:5 dengan Bullet Interaktif</title>
  <style>
    html, body { height: 100%; margin: 0; }
    #ui { position: fixed; inset: 0; display: flex; flex-direction: column; gap: 8px; padding: 12px; pointer-events: none; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .card { align-self: center; background: rgba(0,0,0,.55); color: #fff; border-radius: 12px; padding: 10px 12px; backdrop-filter: blur(6px); max-width: 520px; }
    .row { display: flex; gap: 8px; align-items: center; justify-content: center; }
    .btn { pointer-events: auto; border: 0; border-radius: 999px; padding: 10px 14px; font-weight: 600; background: #06f; color: #fff; }
    .btn[disabled] { opacity: .5; }
    .hint { font-size: 12px; opacity: .9; }
    .badge { background: rgba(255,255,255,.15); padding: 2px 8px; border-radius: 999px; font-size: 12px; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="card" id="supportCard">
      <div class="row" style="justify-content: space-between">
        <div class="badge">Markerless • WebXR</div>
        <div class="badge" id="status">Idle</div>
      </div>
      <div style="margin-top:6px; line-height:1.35">
        <b>Petunjuk:</b> Buka di <b>Chrome Android</b> (ARCore). Ketuk area datar/sekitar poster untuk <b>meletakkan info</b>. Info akan <b>ter-anker</b> di dunia nyata (bukan HUD).
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="start">Mulai AR</button>
        <button class="btn" id="reset" disabled>Reset Anchor</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
    import { XRButton } from 'https://unpkg.com/three@0.161.0/examples/jsm/webxr/XRButton.js';

    const ui = {
      status: document.getElementById('status'),
      btnStart: document.getElementById('start'),
      btnReset: document.getElementById('reset'),
    };

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.1));
    const dir = new THREE.DirectionalLight(0xffffff, .8); dir.position.set(1,2,1); scene.add(dir);

    // --- Buat plane dengan rasio 4:5 ---
    function makeInfoPlane({ widthMeters=0.8, heightMeters=1.0 }={}) {
      const group = new THREE.Group();

      const bg = new THREE.Mesh(
        new THREE.PlaneGeometry(widthMeters, heightMeters),
        new THREE.MeshStandardMaterial({ color: 0x143a66, roughness: 0.9, metalness: 0, side: THREE.DoubleSide })
      );
      group.add(bg);

      // Bullet items (3 kiri, 2 kanan)
      const bullets = [];
      const bulletData = [
        { text: "Bullet 1", url: "https://placekitten.com/400/300" },
        { text: "Bullet 2", url: "https://placekitten.com/401/300" },
        { text: "Bullet 3", url: "https://placekitten.com/402/300" },
        { text: "Bullet 4", url: "https://placekitten.com/403/300" },
        { text: "Bullet 5", url: "https://placekitten.com/404/300" },
      ];

      const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const sphereGeo = new THREE.SphereGeometry(0.03, 16, 16);

      bulletData.forEach((b,i)=>{
        const s = new THREE.Mesh(sphereGeo, bulletMat.clone());
        const col = i<3 ? -0.25 : 0.25;
        const row = i<3 ? (0.3 - i*0.3) : (0.15 - (i-3)*0.3);
        s.position.set(col, row, 0.01);
        s.userData = { url: b.url, text: b.text };
        group.add(s);
        bullets.push(s);
      });

      group.userData.bullets = bullets;
      return group;
    }

    const infoMesh = makeInfoPlane();
    infoMesh.visible = false;
    scene.add(infoMesh);

    // Reticle
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.9 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    let xrRefSpace, xrViewerSpace, xrHitTestSource = null;
    let anchor = null;
    let placing = true;

    function setStatus(t){ ui.status.textContent = t; }

    async function startAR(){
      if (!navigator.xr || !await navigator.xr.isSessionSupported('immersive-ar')) {
        alert('Perangkat/Browser tidak mendukung WebXR AR.');
        return;
      }
      const session = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['hit-test', 'local'],
        optionalFeatures: ['anchors', 'dom-overlay'],
        domOverlay: { root: document.body }
      });

      renderer.xr.setReferenceSpaceType('local');
      await renderer.xr.setSession(session);

      xrRefSpace = await session.requestReferenceSpace('local');
      xrViewerSpace = await session.requestReferenceSpace('viewer');
      xrHitTestSource = await session.requestHitTestSource({ space: xrViewerSpace });

      ui.btnStart.disabled = true;
      ui.btnReset.disabled = false;
      setStatus('Scan permukaan & ketuk untuk tempatkan');

      window.addEventListener('click', onSelect);

      session.addEventListener('end', () => {
        ui.btnStart.disabled = false;
        ui.btnReset.disabled = true;
        reticle.visible = false;
        infoMesh.visible = false;
        anchor = null; placing = true;
        window.removeEventListener('click', onSelect);
      });

      renderer.setAnimationLoop(onXRFrame);
    }

    function resetAnchor(){
      anchor = null;
      infoMesh.visible = false;
      placing = true;
      setStatus('Scan & ketuk untuk tempatkan');
    }

    async function onSelect(event){
      if (!placing) {
        // cek klik ke bullet
        const mouse = new THREE.Vector2((event.clientX/innerWidth)*2-1, -(event.clientY/innerHeight)*2+1);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(infoMesh.userData.bullets||[]);
        if (intersects.length>0){
          const url = intersects[0].object.userData.url;
          window.open(url, '_blank');
        }
        return;
      }

      const frame = renderer.xr.getFrame();
      const hitResults = frame.getHitTestResults(xrHitTestSource);
      if (!hitResults.length) return;

      const hit = hitResults[0];
      const hitPose = hit.getPose(xrRefSpace);

      if (hit.createAnchor) {
        anchor = await hit.createAnchor();
        placing = false;
        infoMesh.visible = true;
      } else {
        const m = new THREE.Matrix4().fromArray(hitPose.transform.matrix);
        infoMesh.matrix.copy(m);
        infoMesh.matrix.decompose(infoMesh.position, infoMesh.quaternion, infoMesh.scale);
        placing = false;
        infoMesh.visible = true;
      }
    }

    function onXRFrame(time, frame){
      if (xrHitTestSource && placing) {
        const hits = frame.getHitTestResults(xrHitTestSource);
        if (hits.length) {
          const hitPose = hits[0].getPose(xrRefSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(hitPose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      } else {
        reticle.visible = false;
      }

      if (anchor && anchor.anchorSpace) {
        const ap = frame.getPose(anchor.anchorSpace, xrRefSpace);
        if (ap) {
          infoMesh.matrix.fromArray(ap.transform.matrix);
          infoMesh.matrix.decompose(infoMesh.position, infoMesh.quaternion, infoMesh.scale);
        }
      }

      renderer.render(scene, camera);
    }

    ui.btnStart.addEventListener('click', startAR);
    ui.btnReset.addEventListener('click', resetAnchor);

    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    });

    (async () => {
      if (!('xr' in navigator)) { setStatus('Browser tidak mendukung WebXR'); return; }
      const ok = await navigator.xr.isSessionSupported('immersive-ar');
      setStatus(ok ? 'Siap • Tekan Mulai AR' : 'AR tidak didukung');
    })();
  </script>
</body>
</html>
