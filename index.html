<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeonAR Poster Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        /* Glass Morphism Design */
        body {
            margin: 0;
            background: linear-gradient(135deg, rgba(20,30,48,0.9) 0%, rgba(36,59,85,0.9) 100%);
            font-family: 'Segoe UI', system-ui;
            overflow: hidden;
            color: white;
        }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        .ar-hud {
            position: fixed;
            top: 20px;
            left: 0;
            right: 0;
            margin: auto;
            width: 90%;
            padding: 15px;
            z-index: 100;
        }

        .point-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.7);
            box-shadow: 0 0 15px cyan;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .point-indicator:hover {
            transform: scale(1.2);
            box-shadow: 0 0 25px cyan;
        }

        .info-card {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
            padding: 20px;
            display: none;
        }

        .calibration-frame {
            position: absolute;
            border: 2px dashed rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7);
            z-index: 50;
        }
    </style>
</head>
<body>
    <!-- Calibration UI -->
    <div id="calibration-ui" class="glass-panel ar-hud">
        <h2 style="text-align: center; margin-top: 0;">POSTER CALIBRATION</h2>
        <p>Frame the poster by dragging the corners</p>
        <div id="calibration-frame" class="calibration-frame"></div>
        <button id="confirm-btn" style="display: block; margin: 20px auto; padding: 10px 25px; background: linear-gradient(90deg, #00d2ff 0%, #3a47d5 100%); border: none; border-radius: 50px; color: white; font-weight: bold;">CONFIRM</button>
    </div>

    <!-- AR Scene -->
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" id="ar-scene" style="display: none;">
        <a-camera gps-camera rotation-reader></a-camera>
        <!-- Dynamic content will be added here -->
    </a-scene>

    <!-- Info Points HUD -->
    <div id="ar-hud" style="display: none;">
        <div class="glass-panel ar-hud">
            <h2 style="text-align: center; margin-top: 0;">POSTER INFO POINTS</h2>
            <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                <div class="point-indicator" data-point="1">1</div>
                <div class="point-indicator" data-point="2">2</div>
                <div class="point-indicator" data-point="3">3</div>
                <div class="point-indicator" data-point="4">4</div>
                <div class="point-indicator" data-point="5">5</div>
            </div>
        </div>
    </div>

    <!-- Info Card -->
    <div id="info-card" class="glass-panel info-card">
        <h3 id="info-title" style="margin-top: 0;">POINT 1</h3>
        <p id="info-content">Loading information...</p>
        <button id="close-btn" style="float: right; background: transparent; border: 1px solid white; color: white; padding: 5px 15px; border-radius: 20px;">CLOSE</button>
    </div>

    <script>
        // Config
        const infoPoints = {
            1: { title: "Quantum Computing", content: "Next-gen processors using qubits for parallel computation" },
            2: { title: "Neural Networks", content: "AI systems mimicking human brain neurons" },
            3: { title: "Space Tourism", content: "Commercial flights to low Earth orbit by 2025" },
            4: { title: "CRISPR Tech", content: "Gene editing with 99% precision in clinical trials" },
            5: { title: "Metaverse", content: "Persistent 3D virtual spaces for work and social" }
        };

        // State
        let posterCorners = [];
        let isCalibrating = true;

        // Init
        document.addEventListener('DOMContentLoaded', () => {
            const calibrationFrame = document.getElementById('calibration-frame');
            const confirmBtn = document.getElementById('confirm-btn');
            
            // Hand Tracking Calibration
            initHandTracking().then(() => {
                console.log("Hand tracking ready");
            });

            // Manual Calibration Fallback
            document.addEventListener('click', (e) => {
                if (!isCalibrating) return;
                
                if (posterCorners.length < 4) {
                    posterCorners.push({ x: e.clientX, y: e.clientY });
                    updateCalibrationFrame();
                    
                    if (posterCorners.length === 4) {
                        confirmBtn.style.display = 'block';
                    }
                }
            });

            confirmBtn.addEventListener('click', () => {
                isCalibrating = false;
                document.getElementById('calibration-ui').style.display = 'none';
                document.getElementById('ar-scene').style.display = 'block';
                document.getElementById('ar-hud').style.display = 'block';
                
                // Calculate poster aspect ratio and position
                const posterRect = calculatePosterRect();
                initARPoints(posterRect);
            });

            // Info Point Interactions
            document.querySelectorAll('.point-indicator').forEach(btn => {
                btn.addEventListener('click', () => {
                    const pointNum = btn.getAttribute('data-point');
                    showInfoCard(pointNum);
                });
            });

            document.getElementById('close-btn').addEventListener('click', () => {
                document.getElementById('info-card').style.display = 'none';
            });
        });

        // Core Functions
        function updateCalibrationFrame() {
            if (posterCorners.length < 2) return;
            
            const frame = document.getElementById('calibration-frame');
            const minX = Math.min(...posterCorners.map(p => p.x));
            const maxX = Math.max(...posterCorners.map(p => p.x));
            const minY = Math.min(...posterCorners.map(p => p.y));
            const maxY = Math.max(...posterCorners.map(p => p.y));
            
            frame.style.left = `${minX}px`;
            frame.style.top = `${minY}px`;
            frame.style.width = `${maxX - minX}px`;
            frame.style.height = `${maxY - minY}px`;
        }

        function calculatePosterRect() {
            return {
                x: posterCorners[0].x,
                y: posterCorners[0].y,
                width: posterCorners[2].x - posterCorners[0].x,
                height: posterCorners[2].y - posterCorners[0].y,
                aspectRatio: (posterCorners[2].x - posterCorners[0].x) / (posterCorners[2].y - posterCorners[0].y)
            };
        }

        function initARPoints(posterRect) {
            const scene = document.getElementById('ar-scene');
            
            // Calculate 5 points in the poster area
            const points = [
                { x: 0.2, y: 0.2 },  // Top-left area
                { x: 0.8, y: 0.2 },  // Top-right
                { x: 0.5, y: 0.5 },  // Center
                { x: 0.2, y: 0.8 },  // Bottom-left
                { x: 0.8, y: 0.8 }   // Bottom-right
            ];
            
            points.forEach((point, index) => {
                const entity = document.createElement('a-entity');
                entity.setAttribute('geometry', 'primitive: circle; radius: 0.5');
                entity.setAttribute('material', 'color: cyan; shader: flat');
                entity.setAttribute('position', {
                    x: (point.x * posterRect.width) / 100,
                    y: -(point.y * posterRect.height) / 100,
                    z: -1
                });
                entity.setAttribute('animation', 'property: scale; to: 1.2 1.2 1; dur: 1000; easing: easeInOutSine; loop: true; dir: alternate');
                entity.setAttribute('data-point', index + 1);
                entity.classList.add('clickable');
                scene.appendChild(entity);
            });
        }

        function showInfoCard(pointNum) {
            const card = document.getElementById('info-card');
            document.getElementById('info-title').textContent = infoPoints[pointNum].title;
            document.getElementById('info-content').textContent = infoPoints[pointNum].content;
            
            // Animate card appearance
            card.style.display = 'block';
            card.style.animation = 'none';
            void card.offsetWidth; // Trigger reflow
            card.style.animation = 'fadeInUp 0.5s ease-out';
        }

        async function initHandTracking() {
            const model = await handpose.load();
            const video = document.createElement('video');
            
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.play();
                
                function detectHands() {
                    model.estimateHands(video).then(predictions => {
                        if (isCalibrating && predictions.length > 0) {
                            const hand = predictions[0];
                            const indexTip = hand.annotations.indexFinger[3];
                            
                            // Convert normalized coordinates to screen space
                            const x = indexTip[0] * window.innerWidth;
                            const y = indexTip[1] * window.innerHeight;
                            
                            // Simulate click at finger tip
                            if (posterCorners.length < 4) {
                                posterCorners.push({ x, y });
                                updateCalibrationFrame();
                            }
                        }
                        requestAnimationFrame(detectHands);
                    });
                }
                detectHands();
            });
        }
    </script>
</body>
</html>
